# 配置与日志管理

> 对标 Spring Boot 的 application.yml + Logback

## Viper 配置管理

Viper 是 Go 生态最流行的配置库，功能对标 Spring Boot 的配置系统。

### 核心功能对照

| Spring Boot | Viper | 说明 |
|-------------|-------|------|
| `application.yml` | `config.yaml` | 配置文件 |
| `@Value("${key}")` | `viper.GetString("key")` | 读取配置 |
| `@ConfigurationProperties` | `viper.Unmarshal(&cfg)` | 绑定结构体 |
| 环境变量覆盖 | `viper.AutomaticEnv()` | ENV 优先 |
| `spring.profiles.active` | 多配置文件 | 环境切换 |

### 安装

```bash
go get github.com/spf13/viper
```

### 完整示例

#### 配置文件 `config.yaml`

```yaml
server:
  port: 8080
  host: localhost

database:
  driver: mysql
  host: localhost
  port: 3306
  name: demo
  user: root
  password: secret

feature:
  enableCache: true
  maxConnections: 100
```

#### 代码实现

```go
package main

import (
    "fmt"
    "log"
    "strings"

    "github.com/spf13/viper"
)

// Config 配置结构体 (类似 @ConfigurationProperties)
type Config struct {
    Server   ServerConfig   `mapstructure:"server"`
    Database DatabaseConfig `mapstructure:"database"`
    Feature  FeatureConfig  `mapstructure:"feature"`
}

type ServerConfig struct {
    Port int    `mapstructure:"port"`
    Host string `mapstructure:"host"`
}

type DatabaseConfig struct {
    Driver   string `mapstructure:"driver"`
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    Name     string `mapstructure:"name"`
    User     string `mapstructure:"user"`
    Password string `mapstructure:"password"`
}

type FeatureConfig struct {
    EnableCache    bool `mapstructure:"enableCache"`
    MaxConnections int  `mapstructure:"maxConnections"`
}

func LoadConfig(path string) (*Config, error) {
    // 1. 设置配置文件
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath(path)
    viper.AddConfigPath(".")

    // 2. 环境变量支持 (SERVER_PORT 覆盖 server.port)
    viper.AutomaticEnv()
    viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

    // 3. 读取配置
    if err := viper.ReadInConfig(); err != nil {
        return nil, fmt.Errorf("读取配置失败: %w", err)
    }

    // 4. 绑定结构体
    var cfg Config
    if err := viper.Unmarshal(&cfg); err != nil {
        return nil, fmt.Errorf("解析配置失败: %w", err)
    }

    return &cfg, nil
}

func main() {
    cfg, err := LoadConfig(".")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("服务器: %s:%d\n", cfg.Server.Host, cfg.Server.Port)
    fmt.Printf("数据库: %s@%s:%d/%s\n",
        cfg.Database.User,
        cfg.Database.Host,
        cfg.Database.Port,
        cfg.Database.Name)
    fmt.Printf("缓存开关: %v\n", cfg.Feature.EnableCache)

    // 动态获取单个值 (类似 @Value)
    fmt.Println("直接读取 server.port:", viper.GetInt("server.port"))
}
```

### 环境变量覆盖

```bash
# 运行时覆盖配置
SERVER_PORT=9090 DATABASE_HOST=prod-db go run main.go
```

---

## 结构化日志

### 方案对比

| 库 | 特点 | 类比 |
|----|------|------|
| `log/slog` | Go 1.21 标准库，推荐 | Logback 基础版 |
| `go.uber.org/zap` | 高性能，字段丰富 | Logback + Logstash |
| `github.com/sirupsen/logrus` | 易用，功能全 | Log4j2 |

### slog 示例 (Go 1.21+)

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    // JSON 格式输出 (生产环境)
    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelDebug,
    }))

    // 结构化日志
    logger.Info("服务启动",
        slog.String("host", "localhost"),
        slog.Int("port", 8080),
    )

    logger.Error("数据库连接失败",
        slog.String("error", "connection refused"),
        slog.String("host", "db.example.com"),
    )
}
```

输出：
```json
{"time":"2024-01-01T12:00:00Z","level":"INFO","msg":"服务启动","host":"localhost","port":8080}
{"time":"2024-01-01T12:00:01Z","level":"ERROR","msg":"数据库连接失败","error":"connection refused","host":"db.example.com"}
```

### Zap 示例

```go
package main

import (
    "go.uber.org/zap"
)

func main() {
    // 开发模式 (彩色输出)
    logger, _ := zap.NewDevelopment()
    defer logger.Sync()

    logger.Info("服务启动",
        zap.String("host", "localhost"),
        zap.Int("port", 8080),
    )

    // 生产模式
    prodLogger, _ := zap.NewProduction()
    prodLogger.Error("请求失败",
        zap.String("path", "/api/users"),
        zap.Int("status", 500),
    )
}
```

### 与 Gin 集成

```go
func GinLogger(logger *slog.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()

        logger.Info("HTTP请求",
            slog.String("method", c.Request.Method),
            slog.String("path", c.Request.URL.Path),
            slog.Int("status", c.Writer.Status()),
            slog.Duration("latency", time.Since(start)),
        )
    }
}
```

---

## 练习

1. 创建 `examples/config/` 示例，读取 YAML 配置并打印
2. 实现环境变量覆盖测试
3. 将 `cmd/todoapi` 改为从配置文件读取端口
